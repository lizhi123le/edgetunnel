name: 混淆并创建 GitHub 发行版

on:
  push:
    branches:
      - main
  workflow_dispatch:    # 手动触发时强制执行全部流程
  schedule:
    - cron: '0 */8 * * *'  # 每8小时检查一次

jobs:
  obfuscate-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
      # Step 1: 检出代码
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      # Step 2: 检查上游更新（核心判断点）
      - name: 检查上游仓库更新并同步备份文件
        id: check-update
        run: |
          set -euo pipefail

          WORKER_URL="https://raw.githubusercontent.com/cmliu/edgetunnel/main/_worker.js"
          TOML_URL="https://raw.githubusercontent.com/cmliu/edgetunnel/main/wrangler.toml"
          BACKUP_FILE="_worker.js.backup"
          TOML_FILE="wrangler.toml"
          WORKER_HASH_FILE=".worker_hash"
          TOML_HASH_FILE=".toml_hash"

          curl -fsSL -o temp_worker.js "$WORKER_URL"
          curl -fsSL -o temp_toml.toml "$TOML_URL"

          NEW_WORKER_HASH=$(sha256sum temp_worker.js | cut -d' ' -f1)
          NEW_TOML_HASH=$(sha256sum temp_toml.toml | cut -d' ' -f1)

          OLD_WORKER_HASH=$(cat "$WORKER_HASH_FILE" 2>/dev/null || echo "")
          OLD_TOML_HASH=$(cat "$TOML_HASH_FILE" 2>/dev/null || echo "")

          HAS_UPDATE="false"

          # 处理 _worker.js.backup
          if [ "$NEW_WORKER_HASH" != "$OLD_WORKER_HASH" ]; then
            echo "上游 _worker.js 已更新"
            mv -f temp_worker.js "$BACKUP_FILE"
            echo "$NEW_WORKER_HASH" > "$WORKER_HASH_FILE"
            HAS_UPDATE="true"
          else
            rm -f temp_worker.js
          fi

          # 处理 wrangler.toml
          if [ ! -f "$TOML_FILE" ] || [ "$NEW_TOML_HASH" != "$OLD_TOML_HASH" ]; then
            echo "wrangler.toml 需要更新或初次创建"
            mv -f temp_toml.toml "$TOML_FILE"
            echo "$NEW_TOML_HASH" > "$TOML_HASH_FILE"
            HAS_UPDATE="true"
          else
            rm -f temp_toml.toml
          fi

          # 首次运行也算更新（备份文件不存在时）
          if [ ! -f "$BACKUP_FILE" ]; then
            mv -f temp_worker.js "$BACKUP_FILE"
            echo "$NEW_WORKER_HASH" > "$WORKER_HASH_FILE"
            HAS_UPDATE="true"
          fi

          echo "has_update=$HAS_UPDATE" >> $GITHUB_OUTPUT
          echo "Upstream check completed. has_update=$HAS_UPDATE"

      # Step 3: 只有在真正有更新 或 手动触发 时才继续
      - name: 执行后续构建（仅在必要时）
        if: |
          steps.check-update.outputs.has_update == 'true' || 
          github.event_name == 'workflow_dispatch'
        run: |
          echo "触发条件满足，开始执行混淆、提交、发布流程..."
          echo "原因: ${{ 
            (steps.check-update.outputs.has_update == 'true' && '上游文件有更新') || 
            '手动触发 (workflow_dispatch)' 
          }}"

      # 下面所有步骤都加上同一个 if 条件（关键！）
      - name: Set up Node.js
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        uses: actions/setup-node@v4
        with:
          node-version: 'latest'

      - name: Install dependencies
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          npm install
          sudo apt-get update -qq
          sudo apt-get install -y jq zip

      # ... 中间所有步骤保持不变，只需要保留这个 if 条件 ...
      # （为了篇幅这里省略，实际复制时全部加上下面这行 if）

      - name: 检查备份文件并创建 _worker_temp.js
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          set -euo pipefail
          WORKER_FILE="_worker.js"
          BACKUP_FILE="_worker.js.backup"
          TEMP_FILE="_worker_temp.js"
          
          # 确保 _worker.js.backup 存在
          if [ ! -f "$BACKUP_FILE" ]; then
            echo "Error: $BACKUP_FILE does not exist in $(pwd)"
            exit 1
          fi
          
          # 创建 _worker_temp.js 从 _worker.js.backup
          cp "$BACKUP_FILE" "$TEMP_FILE" || {
            echo "Error: Failed to create $TEMP_FILE from $BACKUP_FILE"
            exit 1
          }
          
          if [ ! -f "$TEMP_FILE" ]; then
            echo "Error: $TEMP_FILE not found in $(pwd)"
            exit 1
          fi
          
          echo "$TEMP_FILE created successfully from $BACKUP_FILE at $(pwd)/$TEMP_FILE"
          ls -la

      - name: 混淆代码
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          npm run build -- --input _worker_temp.js --output _worker.js

      - name: 压缩为 worker.zip
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          zip worker.zip _worker.js

      - name: 提交并推送更改
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add _worker.js _worker.js.backup wrangler.toml .worker_hash .toml_hash worker.zip || true
          
          if git diff --cached --quiet; then
            echo "没有文件变更，跳过提交"
            exit 0
          fi

          VERSION=$(grep '^name\s*=\s*"' wrangler.toml | sed -E 's/.*"([^"]+)".*/\1/')
          git commit -m "自动更新：混淆版 + 备份 + wrangler.toml（版本 $VERSION）"

      - name: Push changes
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: main

      # 提取版本号和创建 Release 也只在必要时执行
      - name: 提取版本号
        if: steps.check-update.outputs.has_update == 'true' || github.event_name == 'workflow_dispatch'
        id: extract-version
        run: |
          VERSION=$(grep '^name\s*=\s*"' wrangler.toml | sed -E 's/.*"([^"]+)".*/\1/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # 创建 Release（只在有更新时自动创建，手动触发也创建）
      - name: 创建或覆盖 GitHub Release
        if: steps.check-update.outputs.has_update == 'true' && steps.check-version.outputs.skip_release != 'true' || github.event_name == 'workflow_dispatch'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.extract-version.outputs.version }}"

          # 删除旧的同名 release 和 tag（如果存在）
          curl -fsS -X DELETE "https://api.github.com/repos/${{ github.repository }}/releases/tags/$VERSION" || true
          curl -fsS -X DELETE "https://api.github.com/repos/${{ github.repository }}/git/refs/tags/$VERSION" || true

          # 创建新 release
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ github.repository }}/releases \
            -d '{
              "tag_name": "'"$VERSION"'",
              "name": "'"$VERSION"'",
              "body": "自动构建版本（基于 cmliu/edgetunnel 上游）\n混淆版 + 原始备份",
              "draft": false,
              "prerelease": false
            }'

          # 上传资产（自动获取 release_id）
          RELEASE_ID=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/$VERSION" | jq .id)

          for asset in worker.zip _worker.js.backup; do
            curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @"$asset" \
              "https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets?name=$(basename $asset)"
          done

          echo "Release $VERSION 创建并上传资产成功"


